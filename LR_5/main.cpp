#include<iostream>

using namespace std;

const int N = 6;  //размерность матрицы
int S[N][N] = { {0,0,1,1,0,1},    //матрица смежности
                {0,0,0,1,0,0},
                {1,0,0,0,1,1},
                {1,1,0,0,0,0},
                {0,0,1,0,0,1},
                {1,0,1,0,1,0} };
int* tek = new int[N] {};  //текущая комбинация цветов
int* opt = new int[N] {};  //оптимальная комбинация
int Min;			// Минимальное количество цветов

//рекурсия
void fun(int i, int c) { //текущая вершина, количество задействованных цветов
    if (i == N) {  //если прошли все вершины
        if (Min == -1 || c < Min) {  // если текущая комбинация оптимальна, сохраняем ее
            // Запомнить ее
            Min = c;
            for (int k = 0; k < N; k++) opt[k] = tek[k];
        }
        return;  //выходим
    }
    //просмотр всех использованных цветов
    for (int k = 0; k < c; k++) {
        //проверка связанных с текущей вершин на предмет наличия у них k-го цвета
        int p = 1;
        for (int j = 0; j < i; j++) {
            if (S[i][j] == 1 && tek[j] == k) {
                p = 0;
                break;
            }
        }
        //если такого цвета нет - добавить его и перейти к следующему шагу
        if (p == 1) {
            tek[i] = k;
            fun(i + 1, c);
        }
    }
    //новый цвет + след шаг
    tek[i] = c;
    fun(i + 1, c + 1);
}

// Основная функция
int main() {
    Min = -1;  //минимальное количество цветов(изначально -1 - ключ)
    fun(1, 1);  //вызов рекурсии
    cout << "Matrix:" << endl;  //вывод матрицы смежности
    for (int x = 0; x < N; x++) {
        for (int y = 0; y < N; y++) {
            cout << S[x][y] << " ";
        }
        cout << endl;
    }
    cout << endl << "Min color - " << Min << endl << endl;  //вывод результата
    for (int i = 0; i < N; i++)
        cout << "Country " << i + 1 << " - color_" << opt[i] + 1 << endl;
}
